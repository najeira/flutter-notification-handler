import 'dart:async';

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:provider/single_child_widget.dart';
import 'package:rxdart/rxdart.dart' show BehaviorSubject;

/// Signature for a function that creates a widget for a given state.
typedef NotificationHandlerWidgetBuilder<S> = Widget Function(
  BuildContext context,
  S state,
  Widget child,
);

/// Signature for [NotificationHandler.onInit] handler.
typedef NotificationHandlerInitCallback = void Function(
  BuildContext context,
);

/// Signature for [NotificationHandler.onEvent] handler.
typedef NotificationHandlerEventCallback<E, S> = Stream<S> Function(
  BuildContext context,
  E event,
);

/// Captures [Notification] [E] generated by descendants,
/// handles them and provide [S] state to descendants.
class NotificationHandler<E extends Notification, S> extends SingleChildStatefulWidget {
  const NotificationHandler({
    Key key,
    this.initialState,
    this.builder,
    this.onInit,
    @required this.onEvent,
    Widget child,
  })  : assert(onEvent != null),
        assert(builder != null || child != null),
        super(
          key: key,
          child: child,
        );

  /// An optional value to initialize the state to, or null otherwise.
  final S initialState;

  /// Builds a widget depending on the state [S].
  ///
  /// If omitted, [child] is a descendant of this widget.
  final NotificationHandlerWidgetBuilder<S> builder;

  /// Callback invoked after the [NotificationHandler] has been initialized.
  ///
  /// This can be used for dispatching of the first [Notification] after
  /// initialization.
  final NotificationHandlerInitCallback onInit;

  /// Callback for getting notified [E] and provides state [S].
  ///
  /// This function is a stream that can change state asynchronously while
  /// processing events.
  final NotificationHandlerEventCallback<E, S> onEvent;

  @override
  _NotificationHandlerState<E, S> createState() {
    return _NotificationHandlerState<E, S>();
  }
}

/// Captures notifications and add them to stream.
/// 
/// This widget does not know about S, leaves it to the child.
class _NotificationHandlerState<E extends Notification, S> extends SingleChildState<NotificationHandler<E, S>> {
  final StreamController<E> _eventController = StreamController<E>.broadcast();

  @override
  Widget buildWithChild(BuildContext context, Widget child) {
    // If builder is, deliver the provided state.
    if (widget.builder != null) {
      child = Consumer<S>(
        builder: widget.builder,
        child: child,
      );
    }

    return NotificationListener<E>(
      child: _NotificationHandlerInner<E, S>(
        initialState: widget.initialState,
        onInit: widget.onInit,
        onEvent: widget.onEvent,
        eventStream: _eventController.stream,
        child: child,
      ),
      onNotification: (E event) {
        _eventController.sink.add(event);
        return true;
      },
    );
  }

  @override
  void dispose() {
    _eventController.close();
    super.dispose();
  }
}

class _NotificationHandlerInner<E extends Notification, S> extends SingleChildStatefulWidget {
  const _NotificationHandlerInner({
    Key key,
    this.initialState,
    this.onInit,
    @required this.onEvent,
    @required this.eventStream,
    Widget child,
  })  : assert(onEvent != null),
        assert(eventStream != null),
        super(
          key: key,
          child: child,
        );

  final S initialState;

  final NotificationHandlerInitCallback onInit;

  final NotificationHandlerEventCallback<E, S> onEvent;

  final Stream<E> eventStream;

  @override
  _NotificationHandlerInnerState<E, S> createState() {
    return _NotificationHandlerInnerState<E, S>();
  }
}

/// Process events taken from the stream and change state.
class _NotificationHandlerInnerState<E extends Notification, S> extends SingleChildState<_NotificationHandlerInner<E, S>> {
  BehaviorSubject<S> _stateController;

  StreamSubscription<S> _stateSubscription;

  bool _didInit = false;

  @override
  void initState() {
    super.initState();
    _stateController = BehaviorSubject<S>.seeded(widget.initialState);
    _subscribe();
  }

  @override
  void didUpdateWidget(_NotificationHandlerInner<E, S> oldWidget) {
    super.didUpdateWidget(oldWidget);
    assert(widget.eventStream == oldWidget.eventStream);
    if (widget.eventStream != oldWidget.eventStream) {
      _unsubscribe();
      _subscribe();
    }
  }

  @override
  Widget buildWithChild(BuildContext context, Widget child) {
    if (!_didInit) {
      _didInit = true;

      // Where is it appropriate to call onInit?
      if (widget.onInit != null) {
        widget.onInit(context);
      }
    }

    return StreamProvider<S>.value(
      value: _stateController.stream,
      child: child,
    );
  }

  @override
  void dispose() {
    _unsubscribe();
    _stateController.close();
    super.dispose();
  }

  void _subscribe() {
    // Convert notifications E to state S via onEvent callback.
    // No change in the resulting S, should it be skipped?
    final Stream<S> stream = widget.eventStream.asyncExpand<S>(
      (E event) {
        return widget.onEvent(context, event);
      },
    );

    // Connect the stream of events to the stream of state.
    // This will rebuild the widget.
    _stateSubscription = stream.listen(
      (S state) {
        _stateController.sink.add(state);
      },
    );
  }

  void _unsubscribe() {
    if (_stateSubscription != null) {
      _stateSubscription.cancel();
      _stateSubscription = null;
    }
  }
}
